继承：
	方法： 同名函数子类会覆盖父类，object.class::method(),或者用using在类中声明重载。
	虚函数：在函数名后面加override表示虚继承，final修饰表示不继承了。
	纯虚函数：表示类只能继承，不能实例化，一般类中只定义了虚函数，没有其他的内容。
	友元：将其他函数或者类作为自己的类的扩展。
	继承拷贝函数：子类向父类赋值时，调用父类的拷贝构造函数或者拷贝复制函数，因此只复制一部分子类的值。
	一个类只能继承直接基类的构造函数


右值左值：
	1.左值可能同时具备左值属性和右值属性；
	2.左值一般指有地址的变量（不完全对），右值指不能作为左值的值；
	3.左值引用，右值引用，const引用；
		4.这些定义其实是为了作出区分；
		5.左值引用绑定左值，右值引用绑定右值；
		6.返回非引用类型的函数，返回的是右值；相反；
		    	int i = 10;
    			int &&j = i++;
    			int &k = j;
			//    int &&u = j;
	8.移动构造函数：和拷贝构造函数相似，参数换成右值引用
		7.产生临时对象：传参，返回，构造；

noexcept:优化速度，告诉编译器不发生异常

隐式类型转换：有点像拷贝构造函数
类型转换函数：operator int(){};
    一般可以隐式转换，如果有explicit，需要用static_cast()

    可能会出现二异性问题

类成员函数指针：
    更换名字，void (object::*name)(形参)；
    有一个例外，就是类静态函数不需要类的限定符，void (*name)(形参)；

类成员变量指针：
    类成员变量一般是变量在类中的偏移地址
    相反，静态变量不是。


模板：
    1.函数：
        模板函数中可以提供俩中类型：typename T,或者具体类型 int m;
        具体推断看用户传入的值，没有则编译器自动推断；
        编译器推断具体类型的时候，具体类型可以提供值，有或者让编译器推断值；
        注意，具体类型如果由用户提供的话，只能传入字面常量；
        可以申明成inline函数。



模板非类型参数不能是double类型，而且不能是类类型，可以有默认参数；

模板需要注意解释的二异性：
    在用到类中申明的类型时，编译器有可能将它设为静态成员，导致程序错误；需要加上typename消除二异性：
        template<typename T> typename test<T>::iterate test<T>::begin();
        typename的作用是通知编译器，修饰的内容是类型。


typedef int(*funtype)(int, int);


共享模板操作：
    在一个文件中显示创建一个模板，如果其他的文件用则extern声明调用；
    template object<type>; extern template object<type>;


用using结合template使用，可以根据模板定义别名：
    template<typename T> using type = map<T,T>;
    type<int> m;
    或者用typedef代替：
    template<typename T> struct map_{
        typedef map<T,T> type;
    }
    map_<int>::type m;


模板特化：
    定义内容和以前一样：
    template<> void method(type,type){};


可变参模板：
    函数：
    template<typename ...T> returnType method(T&... args){}; 省略号在定义和使用中相反。
        在使用中，一般用递归的方法递归每一个参数，还需要一个无参的同名调用函数用来终止递归。
    类：
    1.递归继承：
    template<typename ...T> class object{};
    template<typename first, typename ...others> object<first, others...>:object<others...>{};
        通过继承实现类递归实例化，当继承到没有参数的类时，创建这个类并停止创建。

    2.递归组合：
    template<typename first, typename ...others> object{
    //构造
    object(first f,others...):my(f),others(others...){};
    object<others...> others;
    first my;
    }

    3.通过类的静态方法，递归调用，然后生成不同的类，传递参数的方法可以用元组的方式：



operator new() 和operator delete():
    是用来申请内存和释放内存的，new关键字会调用。
    补充：
        new关键字申请内存时，会记录申请的大小和位置等信息，等delete删除时会利用这段信息。
        一个什么都没有的类占用1字节，保存地址？
        创建数组会使用额外内存保存数组，大概是四字节。


share_ptr:
    1.没有隐式转换；
    2.创建：1.(); 2.make_shared()
    3.创建之后，只使用ptr进行操作，交换(swap)，赋值，也可以用move移动赋值；
    4.use_count(),unique();
    5.reset(),去掉本身，引用减一,nullptr；
    6.get(),不建议使用;
    7.指定删除器(参数是指针)，一般初始化中可以制定；
    8.数组类管理，注意指定配套删除器。

weak_ptr:
    1.share_ptr的助手，主要起到监视作用；
    2.创建：1.由share_ptr通过构造函数；2.由share_ptr等号赋值；3.由weak_ptr等号赋值；
    3.lock(),资源还在不在，在就返回share_ptr指针,否则返回nullptr;
    4.use_count(),返回share_ptr数量；
    5.expired(),返回bool;
    6.reset(),置空weak_ptr;

使用share_ptr注意循环引用问题。

unique_ptr:
    1.创建：();
    2.只支持移动语义的传值，move；
    3.release(),释放指针；
    4.不使用控制快；
    5.删除器有所不同。


